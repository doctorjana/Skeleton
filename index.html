<!DOCTYPE html>
<html>
	<head>
		<meta charset=utf-8>
<meta name="3d Skeleton" content="https://docjana.com">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link href='https://fonts.googleapis.com/css?family=Roboto' rel='stylesheet' type='text/css'>
<style type="text/css">
body {
    background-color: #000;
    font-family: 'Roboto',sans-serif;
    margin: 0;
    overflow: hidden;
    width: 100%;
    color: #fff;
    text-align: justify;
}
    a{
        color: #FFEC9F;
    }    
    
    .information{
        position: absolute;
        left: 0;
        padding: 5px;
        overflow-y: auto;
    }
    
    @media all and (orientation:portrait){
        .information{bottom:0; width:96%; height: 60%}
    }
    @media all and (orientation:landscape){
        .information{top:0; width:30%; height: 80%}
    }
    
</style>


        
    </head>
    <body>
            <div class="information">
        <h1 id="heading" style="text-transform:uppercase">3d Skeleton</h1>
        <div id="description">Click on a bone to view more information.
            Click and drag to rotate.
            Use your scroll wheel to zoom in or out.
            If you are on a touch device, pinch to zoom and swipe to rotate.
            
            This web experiment uses <a href="https://github.com/mrdoob/three.js/tree/master/examples/js/controls" target="_blank">Trackball controls</a>. Moderate experience is needed to navigate around(sorry for that!).
            <br>
            Powered by <a href="http://threejs.org/" target="_blank">three.js</a>.
        </div>
    </div>
        <script src="view-source:http://cdnjs.cloudflare.com/ajax/libs/three.js/r68/three.min.js"></script>
        
        <script src="http://threejs.org/build/three.min.js"></script>
        <script src="http://threejs.org/examples/js/libs/tween.min.js"></script>
        <script src="OBJLoader.js"></script>
        <script src="ctm.js"></script>
        <script src="CTMLoader.js"></script>
        <script src="lzma.js"></script>
        <script type="text/javascript" src="TrackballControls.js"></script>
        <script src="Projector.js"></script>        
<script>
var container;
var controls;
var camera, scene, renderer;


// custom global variables

var projector, mouse = { x: 0, y: 0 }, INTERSECTED;


    
document.addEventListener("DOMContentLoaded", start_app, false);

function start_app() {
    init();
    animate();
}

function centroidCalculator(geometry){
        var centroid = new THREE.Vector3();
        geometry.computeBoundingBox();
        centroid.addVectors( geometry.boundingBox.min, geometry.boundingBox.max );
        centroid.multiplyScalar( 0.5 );
        centroid.applyMatrix4( mesh.matrixWorld );
        return centroid;
}

function init() {

    container = document.createElement( 'div' );
    document.body.appendChild( container );

    camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 100000 );
    camera.position.z = 1000;

    

    // scene

    scene = new THREE.Scene();


            var geometry = new THREE.BoxGeometry( 0, 0, 0 );
			var material = new THREE.MeshBasicMaterial( { color: 0x00ff00 } );
			var cube = new THREE.Mesh( geometry, material );
			scene.add( cube );
    
            window.cube = cube;
    
    
    
    
    
    
    
    
    
    var ambient = new THREE.AmbientLight( 0x101030 );
    scene.add( ambient );

    var directionalLight = new THREE.DirectionalLight( 0xCABA7B );
    directionalLight.position.set( 0, 0, .1 );
    scene.add( directionalLight );

    var directionalLight = new THREE.DirectionalLight( 0xCABA7B );
    directionalLight.position.set( 0, 0, -1 );
    scene.add( directionalLight );   


    var dirLight = new THREE.DirectionalLight(0xffffff, 0.5);
    dirLight.position.set(100, 100, 50);
    scene.add(dirLight);


    var loader = new THREE.CTMLoader();
    loader.load( 'ctm/Skull.ctm',  function( geometry, material ){
       
    // create mesh and position it
    var material = new THREE.MeshPhongMaterial({ color: 0xFFEC9F, shininess: 15 }),
    mesh = new THREE.Mesh( geometry, material );
    scene.add( mesh ); 
        mesh.name = "Skull";
    mesh.userData =centroidCalculator(geometry);
        mesh.userData.name = "Information about the skull";
    },{});
    
    var loader = new THREE.CTMLoader();
    loader.load( 'ctm/Mandible.ctm',  function( geometry, material ){
    // create mesh and position it
    var material = new THREE.MeshPhongMaterial({ color: 0xFFEC9F, shininess: 15 }),
    mesh = new THREE.Mesh( geometry, material );
    scene.add( mesh ); 
        mesh.name = "Mandible";
    mesh.userData = centroidCalculator(geometry); 
    },{});

    var loader = new THREE.CTMLoader();
    loader.load( 'ctm/Sacrum.ctm',  function( geometry, material ){
    // create mesh and position it
    var material = new THREE.MeshPhongMaterial({ color: 0xFFEC9F, shininess: 15 }),
    mesh = new THREE.Mesh( geometry, material );
    scene.add( mesh ); 
        mesh.name = "Sacrum";
        mesh.userData = centroidCalculator(geometry);      },{});
    
    var loader = new THREE.CTMLoader();
    loader.load( 'ctm/C1.ctm',  function( geometry, material ){
    // create mesh and position it
    var material = new THREE.MeshPhongMaterial({ color: 0xFFEC9F, shininess: 15 }),
    mesh = new THREE.Mesh( geometry, material );
    scene.add( mesh ); 
        mesh.name = "Atlas Vertebra";
        mesh.userData = centroidCalculator(geometry);      },{});
    
    var loader = new THREE.CTMLoader();
    loader.load( 'ctm/C2.ctm',  function( geometry, material ){
    // create mesh and position it
    var material = new THREE.MeshPhongMaterial({ color: 0xFFEC9F, shininess: 15 }),
    mesh = new THREE.Mesh( geometry, material );
    scene.add( mesh ); 
        mesh.name = "Axis";
        mesh.userData = centroidCalculator(geometry);      },{});
    
    var loader = new THREE.CTMLoader();
    loader.load( 'ctm/C3.ctm',  function( geometry, material ){
    // create mesh and position it
    var material = new THREE.MeshPhongMaterial({ color: 0xFFEC9F, shininess: 15 }),
    mesh = new THREE.Mesh( geometry, material );
    scene.add( mesh ); 
        mesh.name = "C3 Vertebra";
        mesh.userData = centroidCalculator(geometry);      },{});    
    
    var loader = new THREE.CTMLoader();
    loader.load( 'ctm/C4.ctm',  function( geometry, material ){
    // create mesh and position it
    var material = new THREE.MeshPhongMaterial({ color: 0xFFEC9F, shininess: 15 }),
    mesh = new THREE.Mesh( geometry, material );
    scene.add( mesh ); 
        mesh.name = "C4 Vertebra";
        mesh.userData = centroidCalculator(geometry);      },{});        
    
    var loader = new THREE.CTMLoader();
    loader.load( 'ctm/C5.ctm',  function( geometry, material ){
    // create mesh and position it
    var material = new THREE.MeshPhongMaterial({ color: 0xFFEC9F, shininess: 15 }),
    mesh = new THREE.Mesh( geometry, material );
    scene.add( mesh ); 
        mesh.name = "C5 Vertebra";
        mesh.userData = centroidCalculator(geometry);      },{});        
    
    var loader = new THREE.CTMLoader();
    loader.load( 'ctm/C6.ctm',  function( geometry, material ){
    // create mesh and position it
    var material = new THREE.MeshPhongMaterial({ color: 0xFFEC9F, shininess: 15 }),
    mesh = new THREE.Mesh( geometry, material );
    scene.add( mesh ); 
        mesh.name = "C6 Vertebra";
        mesh.userData = centroidCalculator(geometry);      },{});        
    
    var loader = new THREE.CTMLoader();
    loader.load( 'ctm/C7.ctm',  function( geometry, material ){
    // create mesh and position it
    var material = new THREE.MeshPhongMaterial({ color: 0xFFEC9F, shininess: 15 }),
    mesh = new THREE.Mesh( geometry, material );
    scene.add( mesh ); 
        mesh.name = "C7 Vertebra";
        mesh.userData = centroidCalculator(geometry);      },{});     
    
    var loader = new THREE.CTMLoader();
    loader.load( 'ctm/L1.ctm',  function( geometry, material ){
    // create mesh and position it
    var material = new THREE.MeshPhongMaterial({ color: 0xFFEC9F, shininess: 15 }),
    mesh = new THREE.Mesh( geometry, material );
    scene.add( mesh ); 
        mesh.name = "L1 Vertebra";
        mesh.userData = centroidCalculator(geometry);      },{}); 
    
    var loader = new THREE.CTMLoader();
    loader.load( 'ctm/L2.ctm',  function( geometry, material ){
    // create mesh and position it
    var material = new THREE.MeshPhongMaterial({ color: 0xFFEC9F, shininess: 15 }),
    mesh = new THREE.Mesh( geometry, material );
    scene.add( mesh ); 
        mesh.name = "L2 Vertebra";
        mesh.userData = centroidCalculator(geometry);      },{}); 
    
    var loader = new THREE.CTMLoader();
    loader.load( 'ctm/L3.ctm',  function( geometry, material ){
    // create mesh and position it
    var material = new THREE.MeshPhongMaterial({ color: 0xFFEC9F, shininess: 15 }),
    mesh = new THREE.Mesh( geometry, material );
    scene.add( mesh ); 
        mesh.name = "L3 Vertebra";
        mesh.userData = centroidCalculator(geometry);      },{}); 
    
    var loader = new THREE.CTMLoader();
    loader.load( 'ctm/L4.ctm',  function( geometry, material ){
    // create mesh and position it
    var material = new THREE.MeshPhongMaterial({ color: 0xFFEC9F, shininess: 15 }),
    mesh = new THREE.Mesh( geometry, material );
    scene.add( mesh ); 
        mesh.name = "L4 Vertebra";
        mesh.userData = centroidCalculator(geometry);      },{}); 
    
    var loader = new THREE.CTMLoader();
    loader.load( 'ctm/L5.ctm',  function( geometry, material ){
    // create mesh and position it
    var material = new THREE.MeshPhongMaterial({ color: 0xFFEC9F, shininess: 15 }),
    mesh = new THREE.Mesh( geometry, material );
    scene.add( mesh ); 
        mesh.name = "L5 Vertebra";
        mesh.userData = centroidCalculator(geometry);      },{}); 
    
    var loader = new THREE.CTMLoader();
    loader.load( 'ctm/T1.ctm',  function( geometry, material ){
    // create mesh and position it
    var material = new THREE.MeshPhongMaterial({ color: 0xFFEC9F, shininess: 15 }),
    mesh = new THREE.Mesh( geometry, material );
    scene.add( mesh ); 
        mesh.name = "T1 Vertebra";
        mesh.userData = centroidCalculator(geometry);      },{}); 
    
    var loader = new THREE.CTMLoader();
    loader.load( 'ctm/T2.ctm',  function( geometry, material ){
    // create mesh and position it
    var material = new THREE.MeshPhongMaterial({ color: 0xFFEC9F, shininess: 15 }),
    mesh = new THREE.Mesh( geometry, material );
    scene.add( mesh ); 
        mesh.name = "T2 Vertebra";
        mesh.userData = centroidCalculator(geometry);      },{}); 
    
    var loader = new THREE.CTMLoader();
    loader.load( 'ctm/T3.ctm',  function( geometry, material ){
    // create mesh and position it
    var material = new THREE.MeshPhongMaterial({ color: 0xFFEC9F, shininess: 15 }),
    mesh = new THREE.Mesh( geometry, material );
    scene.add( mesh ); 
        mesh.name = "T3 Vertebra";
        mesh.userData = centroidCalculator(geometry);      },{}); 
    
    var loader = new THREE.CTMLoader();
    loader.load( 'ctm/T4.ctm',  function( geometry, material ){
    // create mesh and position it
    var material = new THREE.MeshPhongMaterial({ color: 0xFFEC9F, shininess: 15 }),
    mesh = new THREE.Mesh( geometry, material );
    scene.add( mesh ); 
        mesh.name = "T4 Vertebra";
        mesh.userData = centroidCalculator(geometry);      },{}); 
    
    var loader = new THREE.CTMLoader();
    loader.load( 'ctm/T5.ctm',  function( geometry, material ){
    // create mesh and position it
    var material = new THREE.MeshPhongMaterial({ color: 0xFFEC9F, shininess: 15 }),
    mesh = new THREE.Mesh( geometry, material );
    scene.add( mesh ); 
        mesh.name = "T5 Vertebra";
        mesh.userData = centroidCalculator(geometry);      },{}); 
    
    var loader = new THREE.CTMLoader();
    loader.load( 'ctm/T6.ctm',  function( geometry, material ){
    // create mesh and position it
    var material = new THREE.MeshPhongMaterial({ color: 0xFFEC9F, shininess: 15 }),
    mesh = new THREE.Mesh( geometry, material );
    scene.add( mesh ); 
        mesh.name = "T6 Vertebra";
        mesh.userData = centroidCalculator(geometry);      },{}); 
    
    var loader = new THREE.CTMLoader();
    loader.load( 'ctm/T7.ctm',  function( geometry, material ){
    // create mesh and position it
    var material = new THREE.MeshPhongMaterial({ color: 0xFFEC9F, shininess: 15 }),
    mesh = new THREE.Mesh( geometry, material );
    scene.add( mesh ); 
        mesh.name = "T7 Vertebra";
        mesh.userData = centroidCalculator(geometry);      },{}); 
    
    var loader = new THREE.CTMLoader();
    loader.load( 'ctm/T8.ctm',  function( geometry, material ){
    // create mesh and position it
    var material = new THREE.MeshPhongMaterial({ color: 0xFFEC9F, shininess: 15 }),
    mesh = new THREE.Mesh( geometry, material );
    scene.add( mesh ); 
        mesh.name = "T8 Vertebra";
        mesh.userData = centroidCalculator(geometry);      },{}); 
    
    var loader = new THREE.CTMLoader();
    loader.load( 'ctm/T9.ctm',  function( geometry, material ){
    // create mesh and position it
    var material = new THREE.MeshPhongMaterial({ color: 0xFFEC9F, shininess: 15 }),
    mesh = new THREE.Mesh( geometry, material );
    scene.add( mesh ); 
        mesh.name = "T9 Vertebra";
        mesh.userData = centroidCalculator(geometry);      },{}); 
    
    var loader = new THREE.CTMLoader();
    loader.load( 'ctm/T10.ctm',  function( geometry, material ){
    // create mesh and position it
    var material = new THREE.MeshPhongMaterial({ color: 0xFFEC9F, shininess: 15 }),
    mesh = new THREE.Mesh( geometry, material );
    scene.add( mesh ); 
        mesh.name = "T10 Vertebra";
        mesh.userData = centroidCalculator(geometry);      },{}); 
    
    var loader = new THREE.CTMLoader();
    loader.load( 'ctm/T11.ctm',  function( geometry, material ){
    // create mesh and position it
    var material = new THREE.MeshPhongMaterial({ color: 0xFFEC9F, shininess: 15 }),
    mesh = new THREE.Mesh( geometry, material );
    scene.add( mesh ); 
        mesh.name = "T11 Vertebra";
        mesh.userData = centroidCalculator(geometry);      },{}); 
    
    var loader = new THREE.CTMLoader();
    loader.load( 'ctm/T12.ctm',  function( geometry, material ){
    // create mesh and position it
    var material = new THREE.MeshPhongMaterial({ color: 0xFFEC9F, shininess: 15 }),
    mesh = new THREE.Mesh( geometry, material );
    scene.add( mesh ); 
        mesh.name = "T12 Vertebra";
        mesh.userData = centroidCalculator(geometry);      },{}); 
    
    var loader = new THREE.CTMLoader();
    loader.load( 'ctm/ribs/rL1.ctm',  function( geometry, material ){
    // create mesh and position it
    var material = new THREE.MeshPhongMaterial({ color: 0xFFEC9F, shininess: 15 }),
    mesh = new THREE.Mesh( geometry, material );
    scene.add( mesh ); 
        mesh.name = "1st Rib";
        mesh.userData = centroidCalculator(geometry);      },{}); 
    
    var loader = new THREE.CTMLoader();
    loader.load( 'ctm/ribs/rL2.ctm',  function( geometry, material ){
    // create mesh and position it
    var material = new THREE.MeshPhongMaterial({ color: 0xFFEC9F, shininess: 15 }),
    mesh = new THREE.Mesh( geometry, material );
    scene.add( mesh ); 
        mesh.name = "2nd Rib";
        mesh.userData = centroidCalculator(geometry);      },{}); 
    
    var loader = new THREE.CTMLoader();
    loader.load( 'ctm/ribs/rL3.ctm',  function( geometry, material ){
    // create mesh and position it
    var material = new THREE.MeshPhongMaterial({ color: 0xFFEC9F, shininess: 15 }),
    mesh = new THREE.Mesh( geometry, material );
    scene.add( mesh ); 
        mesh.name = "3rd Rib";
        mesh.userData = centroidCalculator(geometry);      },{}); 
    
    var loader = new THREE.CTMLoader();
    loader.load( 'ctm/ribs/rL4.ctm',  function( geometry, material ){
    // create mesh and position it
    var material = new THREE.MeshPhongMaterial({ color: 0xFFEC9F, shininess: 15 }),
    mesh = new THREE.Mesh( geometry, material );
    scene.add( mesh ); 
        mesh.name = "4th Rib";
        mesh.userData = centroidCalculator(geometry);      },{}); 
    
    var loader = new THREE.CTMLoader();
    loader.load( 'ctm/ribs/rL5.ctm',  function( geometry, material ){
    // create mesh and position it
    var material = new THREE.MeshPhongMaterial({ color: 0xFFEC9F, shininess: 15 }),
    mesh = new THREE.Mesh( geometry, material );
    scene.add( mesh ); 
        mesh.name = "5th Rib";
        mesh.userData = centroidCalculator(geometry);      },{}); 
    
    var loader = new THREE.CTMLoader();
    loader.load( 'ctm/ribs/rL6-10.ctm',  function( geometry, material ){
    // create mesh and position it
    var material = new THREE.MeshPhongMaterial({ color: 0xFFEC9F, shininess: 15 }),
    mesh = new THREE.Mesh( geometry, material );
    scene.add( mesh ); 
        mesh.name = "6th to 10th Ribs";
        mesh.userData = centroidCalculator(geometry);      },{}); 

        var loader = new THREE.CTMLoader();
    loader.load( 'ctm/ribs/rR1.ctm',  function( geometry, material ){
    // create mesh and position it
    var material = new THREE.MeshPhongMaterial({ color: 0xFFEC9F, shininess: 15 }),
    mesh = new THREE.Mesh( geometry, material );
    scene.add( mesh ); 
        mesh.name = "1st Rib";
        mesh.userData = centroidCalculator(geometry);      },{}); 
    
    var loader = new THREE.CTMLoader();
    loader.load( 'ctm/ribs/rR2.ctm',  function( geometry, material ){
    // create mesh and position it
    var material = new THREE.MeshPhongMaterial({ color: 0xFFEC9F, shininess: 15 }),
    mesh = new THREE.Mesh( geometry, material );
    scene.add( mesh ); 
        mesh.name = "2nd Rib";
        mesh.userData = centroidCalculator(geometry);      },{}); 
    
    var loader = new THREE.CTMLoader();
    loader.load( 'ctm/ribs/rR3.ctm',  function( geometry, material ){
    // create mesh and position it
    var material = new THREE.MeshPhongMaterial({ color: 0xFFEC9F, shininess: 15 }),
    mesh = new THREE.Mesh( geometry, material );
    scene.add( mesh ); 
        mesh.name = "3rd Rib";
        mesh.userData = centroidCalculator(geometry);      },{}); 
    
    var loader = new THREE.CTMLoader();
    loader.load( 'ctm/ribs/rR4.ctm',  function( geometry, material ){
    // create mesh and position it
    var material = new THREE.MeshPhongMaterial({ color: 0xFFEC9F, shininess: 15 }),
    mesh = new THREE.Mesh( geometry, material );
    scene.add( mesh ); 
        mesh.name = "4th Rib";
        mesh.userData = centroidCalculator(geometry);      },{}); 
    
    var loader = new THREE.CTMLoader();
    loader.load( 'ctm/ribs/rR5.ctm',  function( geometry, material ){
    // create mesh and position it
    var material = new THREE.MeshPhongMaterial({ color: 0xFFEC9F, shininess: 15 }),
    mesh = new THREE.Mesh( geometry, material );
    scene.add( mesh ); 
        mesh.name = "5th Rib";
        mesh.userData = centroidCalculator(geometry);      },{}); 
    
    var loader = new THREE.CTMLoader();
    loader.load( 'ctm/ribs/rR6-10.ctm',  function( geometry, material ){
    // create mesh and position it
    var material = new THREE.MeshPhongMaterial({ color: 0xFFEC9F, shininess: 15 }),
    mesh = new THREE.Mesh( geometry, material );
    scene.add( mesh ); 
        mesh.name = "6th to 10th Ribs";
        mesh.userData = centroidCalculator(geometry);      },{}); 
    
    var loader = new THREE.CTMLoader();
    loader.load( 'ctm/UL/Left_Clavicle.ctm',  function( geometry, material ){
    // create mesh and position it
    var material = new THREE.MeshPhongMaterial({ color: 0xFFEC9F, shininess: 15 }),
    mesh = new THREE.Mesh( geometry, material );
    scene.add( mesh ); 
        mesh.name = "Left Clavicle";

        // this is awesome : controls.target.set( 550, 50, 100 );
        mesh.userData = centroidCalculator(geometry);      },{}); 

    var loader = new THREE.CTMLoader();
    loader.load( 'ctm/UL/Left_Humerus.ctm',  function( geometry, material ){
    // create mesh and position it
    var material = new THREE.MeshPhongMaterial({ color: 0xFFEC9F, shininess: 15 }),
    mesh = new THREE.Mesh( geometry, material );
    scene.add( mesh ); 
        mesh.name = "Left Humerus";
        mesh.userData = centroidCalculator(geometry);      },{}); 

    var loader = new THREE.CTMLoader();
    loader.load( 'ctm/UL/Left_Radius.ctm',  function( geometry, material ){
    // create mesh and position it
    var material = new THREE.MeshPhongMaterial({ color: 0xFFEC9F, shininess: 15 }),
    mesh = new THREE.Mesh( geometry, material );
    scene.add( mesh ); 
        mesh.name = "Left Radius";
        mesh.userData = centroidCalculator(geometry);      },{});     
    
    var loader = new THREE.CTMLoader();
    loader.load( 'ctm/UL/Left_Ulna.ctm',  function( geometry, material ){
    // create mesh and position it
    var material = new THREE.MeshPhongMaterial({ color: 0xFFEC9F, shininess: 15 }),
    mesh = new THREE.Mesh( geometry, material );
    scene.add( mesh ); 
        mesh.name = "Left Radius";
        mesh.userData = centroidCalculator(geometry);      },{});       
 
    var loader = new THREE.CTMLoader();
    loader.load( 'ctm/UL/Left_Scapula.ctm',  function( geometry, material ){
    // create mesh and position it
    var material = new THREE.MeshPhongMaterial({ color: 0xFFEC9F, shininess: 15 }),
    mesh = new THREE.Mesh( geometry, material );
    scene.add( mesh ); 
        mesh.name = "Left Scapula";
        mesh.userData = centroidCalculator(geometry);      },{});      
    
    
    var loader = new THREE.CTMLoader();
    loader.load( 'ctm/UL/Right_Clavicle.ctm',  function( geometry, material ){
    // create mesh and position it
    var material = new THREE.MeshPhongMaterial({ color: 0xFFEC9F, shininess: 15 }),
    mesh = new THREE.Mesh( geometry, material );
    scene.add( mesh ); 
        mesh.name = "Right Clavicle";
        mesh.userData = centroidCalculator(geometry);      },{}); 

    var loader = new THREE.CTMLoader();
    loader.load( 'ctm/UL/Right_Humerus.ctm',  function( geometry, material ){
    // create mesh and position it
    var material = new THREE.MeshPhongMaterial({ color: 0xFFEC9F, shininess: 15 }),
    mesh = new THREE.Mesh( geometry, material );
    scene.add( mesh ); 
        mesh.name = "Right Humerus";
        mesh.userData = centroidCalculator(geometry);      },{}); 

    var loader = new THREE.CTMLoader();
    loader.load( 'ctm/UL/Right_Radius.ctm',  function( geometry, material ){
    // create mesh and position it
    var material = new THREE.MeshPhongMaterial({ color: 0xFFEC9F, shininess: 15 }),
    mesh = new THREE.Mesh( geometry, material );
    scene.add( mesh ); 
        mesh.name = "Right Radius";
        mesh.userData = centroidCalculator(geometry);      },{});     
    
    var loader = new THREE.CTMLoader();
    loader.load( 'ctm/UL/Right_Ulna.ctm',  function( geometry, material ){
    // create mesh and position it
    var material = new THREE.MeshPhongMaterial({ color: 0xFFEC9F, shininess: 15 }),
    mesh = new THREE.Mesh( geometry, material );
    scene.add( mesh ); 
        mesh.name = "Right Radius";
        mesh.userData = centroidCalculator(geometry);      },{});     
    
    var loader = new THREE.CTMLoader();
    loader.load( 'ctm/UL/Right_Scapula.ctm',  function( geometry, material ){
    // create mesh and position it
    var material = new THREE.MeshPhongMaterial({ color: 0xFFEC9F, shininess: 15 }),
    mesh = new THREE.Mesh( geometry, material );
    scene.add( mesh ); 
        mesh.name = "Right Scapula";
        mesh.userData = centroidCalculator(geometry);      },{});        
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    //

    renderer = new THREE.WebGLRenderer({ alpha: true });
    renderer.setPixelRatio( window.devicePixelRatio );
    renderer.setSize( window.innerWidth, window.innerHeight );
    container.appendChild( renderer.domElement );
//controls
    controls = new THREE.TrackballControls(camera, renderer.domElement);
    controls.rotateSpeed = 0.8;
    controls.noZoom = false;
    controls.noPan = false;
    controls.staticMoving = false;
    controls.minDistance = 50;
    controls.maxDistance = 1300;
    controls.dynamicDampingFactor = 0.5;


        

    
//skybox


    texture_placeholder = document.createElement( 'canvas' );
    texture_placeholder.width = 128;
    texture_placeholder.height = 128;
    var context = texture_placeholder.getContext( '2d' );
    context.fillStyle = 'rgb( 200, 200, 200 )';
    context.fillRect( 0, 0, texture_placeholder.width, texture_placeholder.height );   
    var materials = [
        loadTexture( 'img/starfield_rt.jpg' ), // right
        loadTexture( 'img/starfield_lf.jpg' ), // left
        loadTexture( 'img/starfield_up.jpg' ), // top
        loadTexture( 'img/starfield_dn.jpg' ), // bottom
        loadTexture( 'img/starfield_bk.jpg' ), // back
        loadTexture( 'img/starfield_ft.jpg' )  // front
    ];
    mesh = new THREE.Mesh( new THREE.BoxGeometry(3000, 3000, 3000, 7, 7, 7 ), new THREE.MultiMaterial( materials ) );
    mesh.scale.x = - 1;
    scene.add( mesh );    


function loadTexture( path ) {
    var texture = new THREE.Texture( texture_placeholder );
    var material = new THREE.MeshBasicMaterial( { map: texture, overdraw: 0.5 } );
    var image = new Image();
    image.onload = function () {
        texture.image = this;
        texture.needsUpdate = true;
    };
    image.src = path;
    return material;
}    

    window.addEventListener( 'resize', onWindowResize, false );
	
    // initialize object to perform world/screen calculations
	projector = new THREE.Projector();

    
    
	// when the mouse moves, call the given function
	document.addEventListener( 'click', onDocumentMouseClick, false );
}

function onDocumentMouseClick( event ) 
{
	// the following line would stop any other event handler from firing
	// (such as the mouse's TrackballControls)
	event.preventDefault();
	
	// update the mouse variable
	mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
	mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
    
    	// find intersections

	// create a Ray with origin at the mouse position
	//   and direction into the scene (camera direction)
	var vector = new THREE.Vector3( mouse.x, mouse.y, 1 );
	vector.unproject( camera );
	var ray = new THREE.Raycaster( camera.position, vector.sub( camera.position ).normalize() );

	// create an array containing all objects in the scene with which the ray intersects
	var intersects = ray.intersectObjects( scene.children );

	// INTERSECTED = the object in the scene currently closest to the camera 
	//		and intersected by the Ray projected from the mouse position 	
	
	// if there is one (or more) intersections
	if ( intersects.length > 0 )
	{
		// if the closest object intersected is not the currently stored intersection object
		if ( intersects[ 0 ].object != INTERSECTED ) 
		{
            
		    // restore previous intersection object (if it exists) to its original color
			if ( INTERSECTED ) 
                
				INTERSECTED.material.color.setHex( INTERSECTED.currentHex );
			     // store reference to closest object as current intersection object
                INTERSECTED = intersects[ 0 ].object;
                // store color of closest object (for later restoration)
                INTERSECTED.currentHex = INTERSECTED.material.color.getHex();
                // set a new color for closest object
                INTERSECTED.material.color.setHex( 0xf44336 );
                console.log(INTERSECTED.userData);
                

                

  //tween          


            if(INTERSECTED.userData.x){
                var from = {
                    x: cube.position.x,
                    y: cube.position.y,
                    z: cube.position.z
                };

                var to = {
                    x: -INTERSECTED.userData.x,
                    y: INTERSECTED.userData.y,
                    z: INTERSECTED.userData.z
                };
                var tween = new TWEEN.Tween(from)
                    .to(to, 2000)
                    .easing(TWEEN.Easing.Linear.None)
                    .onUpdate(function () {
                    cube.position.set(this.x, this.y, this.z);

                })
                    .onComplete(function () {
                    console.log("Finally")
                })
                    .start();
  
                var repeat = function () {
                    TWEEN.update();
                    requestAnimationFrame(repeat);

                };

                repeat();   
            
            }
            
            
            
                //replace
                document.getElementById("heading").innerHTML= INTERSECTED.name;
                document.getElementById("description").innerHTML= INTERSECTED.userData.name;
                
            }
        } 
        else // there are no intersections
        {
            // restore previous intersection object (if it exists) to its original color
            if ( INTERSECTED ) 
                INTERSECTED.material.color.setHex( INTERSECTED.currentHex );
            // remove previous intersection object reference
            //     by setting current intersection object to "nothing"
            INTERSECTED = null;

        }
}
//hover feature
 function onDocumentMouseHover( event ) 
{
	// the following line would stop any other event handler from firing
	// (such as the mouse's TrackballControls)
	//event.preventDefault();
	
	// update the mouse variable
	mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
	mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
    
    	// find intersections

	// create a Ray with origin at the mouse position
	//   and direction into the scene (camera direction)
	var vector = new THREE.Vector3( mouse.x, mouse.y, 1 );
	vector.unproject( camera );
	var ray = new THREE.Raycaster( camera.position, vector.sub( camera.position ).normalize() );

	// create an array containing all objects in the scene with which the ray intersects
	var intersects = ray.intersectObjects( scene.children );

	// INTERSECTED = the object in the scene currently closest to the camera 
	//		and intersected by the Ray projected from the mouse position 	
	
	// if there is one (or more) intersections
	if ( intersects.length > 0 )
	{
		// if the closest object intersected is not the currently stored intersection object
		if ( intersects[ 0 ].object != INTERSECTED ) 
		{
            
		    // restore previous intersection object (if it exists) to its original color
			if ( INTERSECTED ) 
                
				INTERSECTED.material.color.setHex( INTERSECTED.currentHex );
			     // store reference to closest object as current intersection object
                INTERSECTED = intersects[ 0 ].object;
                // store color of closest object (for later restoration)
                INTERSECTED.currentHex = INTERSECTED.material.color.getHex();
                // set a new color for closest object
                INTERSECTED.material.color.setHex( 0xf44336 );
                console.log(INTERSECTED.userData);
                

                

  //tween          


            if(INTERSECTED.userData.x){
                var from = {
                    x: cube.position.x,
                    y: cube.position.y,
                    z: cube.position.z
                };

                var to = {
                    x: -INTERSECTED.userData.x,
                    y: INTERSECTED.userData.y,
                    z: INTERSECTED.userData.z
                };
                var tween = new TWEEN.Tween(from)
                    .to(to, 2000)
                    .easing(TWEEN.Easing.Linear.None)
                    .onUpdate(function () {
                    cube.position.set(this.x, this.y, this.z);

                })
                    .onComplete(function () {
                    console.log("Finally")
                })
                    .start();
  
                var repeat = function () {
                    TWEEN.update();
                    requestAnimationFrame(repeat);

                };

                repeat();   
            
            }
            
            
            
                //replace
                document.getElementById("heading").innerHTML= INTERSECTED.name;
                document.getElementById("description").innerHTML= INTERSECTED.userData.name;
                
            }
        } 
        else // there are no intersections
        {
            // restore previous intersection object (if it exists) to its original color
            if ( INTERSECTED ) 
                INTERSECTED.material.color.setHex( INTERSECTED.currentHex );
            // remove previous intersection object reference
            //     by setting current intersection object to "nothing"
            INTERSECTED = null;

        }
}   
    
    
function onWindowResize() {


    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();

    renderer.setSize( window.innerWidth, window.innerHeight );

}

function update()
{


}

    


function animate() {
    requestAnimationFrame( animate );
    controls.update();
    render();
    update();
}

function render() {
    camera.lookAt( cube.position );
    
    renderer.setClearColor( 0x212121, 1);
    renderer.render( scene, camera );


}



		</script>
	</body>
</html>