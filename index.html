<!DOCTYPE html>
<html>
	<head>
		<meta charset=utf-8>
		<title>Human Skeleton in 3d</title>
        
<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<style>
			body { margin: 0; }
			canvas { width: 100%; height: 100% }
            .mytext{
                position:fixed;
                color:#fff;
                font-family:Roboto;
                padding: 10px;
            }
            .heading{
                font-size: 30px;
                text-align: center;
                text-transform: uppercase;
                font-weight: bold;
            }
            .desc{
                font-size: 20px;
                text-align: justify;
                overflow: auto             
            }
            @media all and (orientation: landscape){
                .mytext{width: 40%}
                .heading{color: #ffeb3b}
                .desc{top: 20%; height: 60%; left: 2%; background-color: #424242;}
            }
            @media all and (orientation: portrait){
                .mytext{width: 96%}
                .heading{bottom: 0px; color: white; background-color: #ffeb3b;}
                .desc{height: 45%; bottom: 56px}
            }
		</style>
        <link href='https://fonts.googleapis.com/css?family=Roboto' rel='stylesheet' type='text/css'>
	</head>
	<body>
        <div id="heading" class="mytext heading">Hello Friends</div>
        
        <div class="mytext desc" id="description">Halvah cookie oat cake bonbon jelly oat cake bear claw marshmallow brownie. Tiramisu muffin carrot cake pudding sesame snaps gummi bears halvah. Danish dragée biscuit ice cream dessert. Tootsie roll cotton candy marshmallow tootsie roll chupa chups lollipop gummi bears. Tiramisu jelly-o sweet chocolate marshmallow dessert. Dragée wafer ice cream. Tart gummi bears jelly-o danish lollipop fruitcake. Liquorice muffin donut chupa chups soufflé macaroon halvah pie. Cotton candy cookie lemon drops chocolate cake dragée halvah. Brownie danish topping sesame snaps lollipop lemon drops muffin pie jelly beans. Topping chocolate dessert pie cheesecake. Tart carrot cake tiramisu toffee pudding pastry chupa chups. Marshmallow cookie dragée donut pudding danish cheesecake gummi bears oat cake. Cake tiramisu sugar plum jelly.</div>
        
        
		<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r74/three.min.js"></script>
        <script src="OBJLoader.js"></script>
        <script src="ctm.js"></script>
        <script src="CTMLoader.js"></script>
        <script src="lzma.js"></script>
        <script src="OrbitControls.js"></script>
        <script src="Projector.js"></script>

<script>
var container;

var camera, scene, renderer;


// custom global variables
var cube;
var projector, mouse = { x: 0, y: 0 }, INTERSECTED;

init();
animate();


function init() {

    container = document.createElement( 'div' );
    document.body.appendChild( container );

    camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 100000 );
    camera.position.z = 1000;

    var controls	= new THREE.OrbitControls(camera)

    // scene

    scene = new THREE.Scene();

    var ambient = new THREE.AmbientLight( 0x101030 );
    scene.add( ambient );

    var directionalLight = new THREE.DirectionalLight( 0xCABA7B );
    directionalLight.position.set( 0, 0, .1 );
    scene.add( directionalLight );

    var directionalLight = new THREE.DirectionalLight( 0xCABA7B );
    directionalLight.position.set( 0, 0, -1 );
    scene.add( directionalLight );   


    var dirLight = new THREE.DirectionalLight(0xffffff, 0.5);
    dirLight.position.set(100, 100, 50);
    scene.add(dirLight);


    var loader = new THREE.CTMLoader();
    loader.load( 'ctm/Skull.ctm',  function( geometry, material ){
    // create mesh and position it
    var material = new THREE.MeshPhongMaterial({ color: 0xFFEC9F, shininess: 15 }),
    mesh = new THREE.Mesh( geometry, material );
    scene.add( mesh ); 
        mesh.name = "skull";
    }, {} );
    
    var loader = new THREE.CTMLoader();
    loader.load( 'ctm/Sternum.ctm',  function( geometry, material ){
    // create mesh and position it
    var material = new THREE.MeshPhongMaterial({ color: 0xFFEC9F, shininess: 15 }),
    mesh = new THREE.Mesh( geometry, material );
    scene.add( mesh ); 
        mesh.name = "sternum";
    }, {} );

    //

    renderer = new THREE.WebGLRenderer({ alpha: true });
    renderer.setPixelRatio( window.devicePixelRatio );
    renderer.setSize( window.innerWidth, window.innerHeight );
    container.appendChild( renderer.domElement );


    //

    window.addEventListener( 'resize', onWindowResize, false );
	
    // initialize object to perform world/screen calculations
	projector = new THREE.Projector();
	
	// when the mouse moves, call the given function
	document.addEventListener( 'mousemove', onDocumentMouseMove, false );
}

function onDocumentMouseMove( event ) 
{
	// the following line would stop any other event handler from firing
	// (such as the mouse's TrackballControls)
	// event.preventDefault();
	
	// update the mouse variable
	mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
	mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
}
function onWindowResize() {


    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();

    renderer.setSize( window.innerWidth, window.innerHeight );

}

function update()
{
	// find intersections

	// create a Ray with origin at the mouse position
	//   and direction into the scene (camera direction)
	var vector = new THREE.Vector3( mouse.x, mouse.y, 1 );
	vector.unproject( camera );
	var ray = new THREE.Raycaster( camera.position, vector.sub( camera.position ).normalize() );

	// create an array containing all objects in the scene with which the ray intersects
	var intersects = ray.intersectObjects( scene.children );

	// INTERSECTED = the object in the scene currently closest to the camera 
	//		and intersected by the Ray projected from the mouse position 	
	
	// if there is one (or more) intersections
	if ( intersects.length > 0 )
	{
		// if the closest object intersected is not the currently stored intersection object
		if ( intersects[ 0 ].object != INTERSECTED ) 
		{
            
		    // restore previous intersection object (if it exists) to its original color
			if ( INTERSECTED ) 
                
				INTERSECTED.material.color.setHex( INTERSECTED.currentHex );
			     // store reference to closest object as current intersection object
                INTERSECTED = intersects[ 0 ].object;
                // store color of closest object (for later restoration)
                INTERSECTED.currentHex = INTERSECTED.material.color.getHex();
                // set a new color for closest object
                INTERSECTED.material.color.setHex( 0xf44336 );
                
                console.log(INTERSECTED.name);
                
                //replace
                document.getElementById("heading").innerHTML= INTERSECTED.name;
                document.getElementById("description").innerHTML= INTERSECTED.name;
                
            }
        } 
        else // there are no intersections
        {
            // restore previous intersection object (if it exists) to its original color
            if ( INTERSECTED ) 
                INTERSECTED.material.color.setHex( INTERSECTED.currentHex );
            // remove previous intersection object reference
            //     by setting current intersection object to "nothing"
            INTERSECTED = null;

        }

}

//

function animate() {
    requestAnimationFrame( animate );
    render();
    update();
}

function render() {
    camera.lookAt( scene.position );
    renderer.setClearColor( 0x212121, 1);
    renderer.render( scene, camera );

}



		</script>
	</body>
</html>